// Copyright 2021 Nash Muhandes
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//===========================================================================
//
// StrifeCoopHandler
//
//===========================================================================

class StrifeCoopHandler : EventHandler
{
	const PARTY_DISTANCE = 200.0;

	// keep a global record of QuestItems acquired throughout the journey
	Array< class<Inventory> > retrievedQuestItems;

	// track player stats globally
	// ATTENTION: this is obviously designed for Strife's single player campaign where it's not designed
	// for each player to have individual upgrades.
	// For a custom campaign where such things would be allowed, this would need to reworked.
	int maxStamina, maxAccuracy;

	//===========================================================================
	//
	//
	//
	//===========================================================================

	override void PlayerEntered(PlayerEvent e)
	{
		let pmo = players[e.PlayerNumber].mo;
		if (pmo)
		{
			SetupPlayer(pmo);
		}
	}

	override void PlayerRespawned(PlayerEvent e)
	{
		let pmo = players[e.PlayerNumber].mo;
		if (pmo)
		{
			SetupPlayer(pmo);
		}
	}

	override void PlayerDied(PlayerEvent e)
	{
	}

	override void PlayerDisconnected(PlayerEvent e)
	{
		TransferQuestItems(e);
	}

	//===========================================================================
	//
	//
	//
	//===========================================================================

	override void WorldLoaded(WorldEvent e)
	{
		WakeStartingEnemiesInTown();
	}

	override void WorldTick(void)
	{
		HandleQuestItems();
	}

	override void WorldUnloaded(WorldEvent e)
	{
	}

	override void WorldThingSpawned(WorldEvent e)
	{
		SetupNPCs(e);
	}

	override void WorldThingDied(WorldEvent e)
	{
		HandleAlienSpectre5Death(e);
	}

	override void WorldLinePreActivated(WorldEvent e)
	{
		HandleCommunicatorLines(e);
	}

	//===========================================================================
	//
	//
	//
	//===========================================================================

	override void NetworkProcess(ConsoleEvent e)
	{
		PlayerPawn pmo = PlayerPawn(players[e.Player].mo);
		if (!pmo) return;
		if (pmo && !pmo.player) return;
		bool isConsolePlayer = (pmo == PlayerPawn(players[consoleplayer].mo));

		//===========================================================================
		//
		// EV_ClearConversationStuff
		//
		//===========================================================================
		if (e.Name == 'EV_ClearConversationStuff')
		{
			pmo.player.ConversationFaceTalker = false;
			pmo.player.ConversationNPC = NULL;
			pmo.player.ConversationPC = NULL;
			pmo.player.ConversationNPCAngle = 0.;
		}
	}

	//===========================================================================
	//
	//
	//
	//===========================================================================

	override void RenderOverlay(RenderEvent e)
	{
		PlayerInfo plr;

		if (e.Camera is "PlayerPawn" && e.Camera == players[consoleplayer].camera && e.Camera.player)
		{
			plr = e.Camera.player;
		}

		if (!plr) return;

		int debugMode = CVar.GetCVar("strifecoop_debug", plr).GetInt();
		if (debugMode <= 0) return;

		DrawDebugText(plr, debugMode);
	}

	//===========================================================================
	//
	//
	//
	//===========================================================================

	void SetupPlayer(PlayerPawn pmo)
	{
		if (!pmo) return;

		// Enable player plugin
		let plugin = StrifeCoopPlayerPlugin(pmo.FindInventory("StrifeCoopPlayerPlugin", true));
		if (!plugin)
		{
			pmo.A_GiveInventory("StrifeCoopPlayerPlugin");
		}

		if (plugin)
		{
			// if these values are non-zero, we can assume a current game is in progrss
			if (maxStamina > 0 || maxAccuracy > 0)
			{
				plugin.oldStamina = plugin.newStamina = maxStamina;
				plugin.oldAccuracy = plugin.newAccuracy = maxAccuracy;
				plugin.DoUpdateStamina(pmo, maxStamina);
				plugin.DoUpdateAccuracy(pmo, maxAccuracy);
			}
		}
	}

	void SetupNPCs(WorldEvent e)
	{
		// Inject custom logic into all NPCs
		if (e.Thing && e.Thing.bIsMonster)
		{
			Actor npc = e.Thing;
			npc.A_GiveInventory("StrifeCoopNPCPlugin", 1);
		}
	}

	//===========================================================================
	//
	//
	//
	//===========================================================================

	void WakeStartingEnemiesInTown(void)
	{
		if (!multiplayer) return;

		// Wake the Acolytes up in the first room immediately, targetting a random player
		if (level.totaltime == 0 && level.levelnum == 2)
		{
			int totalPlayers = 0;
			for (int i = 0; i < MAXPLAYERS; i++)
			{
				if (playeringame[i]) totalPlayers++;
			}

			int p = random[RNG_TargetRandomPlayer](0, totalPlayers - 1);

			players[p].mo.SoundAlert(players[p].mo, false);
		}
	}

	//===========================================================================
	//
	//
	//
	//===========================================================================

	void HandleQuestItems(void)
	{
		if (!multiplayer) return;

		// No, there really isn't a better way to do this for the vanilla quest items.
		// Actor replacement doesn't work because too many parts of the game check for the
		// original items directly by class name.

		// First, collect all of the items each player has
		for (int i = 0; i < MAXPLAYERS; i++)
		{
			if (playeringame[i])
			{
				PlayerInfo plr = players[i];
				let pmo = players[i].mo;

				if (pmo && plr)
				{
					for (Inventory item = pmo.Inv; item != NULL; item = item.Inv)
					{
						if (item is "QuestItem" || item is "Communicator" || item is "StrifeKey" || item is "PrisonPass")
						{
							class<Inventory> cls = item.GetClass();
							if (cls)
							{
								if (retrievedQuestItems.Find(cls) == retrievedQuestItems.Size())
								{
									//Console.Printf("Found %s on player %d", cls.GetClassName(), pmo.PlayerNumber() + 1);
									retrievedQuestItems.Push(cls);
								}
							}
						}
					}
				}
			}
		}

		// Then, distribute the items to all players
		for (int i = 0; i < MAXPLAYERS; i++)
		{
			if (playeringame[i])
			{
				PlayerInfo plr = players[i];
				let pmo = players[i].mo;

				if (pmo && plr)
				{
					for (int j = 0; j < retrievedQuestItems.Size(); j++)
					{
						let a = pmo.FindInventory(retrievedQuestItems[j], true);
						if (!a)
						{
							//Console.Printf("Giving %s to player %d", retrievedQuestItems[j].GetClassName(), pmo.PlayerNumber() + 1);
							pmo.A_GiveInventory(retrievedQuestItems[j], 1);
						}
					}
				}
			}
		}
	}

	void TransferQuestItems(PlayerEvent e)
	{
		// TO DO: when a player disconnects, transfer the pickup-able quest item
		// (Beldin's ring, power coupling etc) to the next online player.
	}

	//===========================================================================
	//
	//
	//
	//===========================================================================

	void HandleAlienSpectre5Death(WorldEvent e)
	{
		if (!multiplayer) return;

		// AlienSpectre5 (the Loremaster's spectre) is hardcoded to only give upgrades when killed in single player.
		// We deal with that here.
		// It's okay to give the upgrades to every player unconditionally because according the base class code,
		// players get ZERO upgrades in multiplayer :S
		if (e.Thing && e.Thing is "AlienSpectre5")
		{
			PlayerPawn plr = NULL;
			for (int i = 0; i < MAXPLAYERS; ++i)
			{
				if (playeringame[i])
				{
					plr = players[i].mo;
					plr.GiveInventoryType("UpgradeStamina");
					plr.GiveInventoryType("UpgradeAccuracy");
				}
			}
		}
	}

	//===========================================================================
	//
	//
	//
	//===========================================================================

	void HandleCommunicatorLines(WorldEvent e)
	{
		// This is for handling all of the lines that were directly given the "Sound Activate Comm Unit" lines,
		// instead of the ACS-based one
		if (e.Thing is "PlayerPawn")
		{
			PlayerPawn pmo = PlayerPawn(e.Thing);
			if (!pmo) return;

			// According to Strife's XLAT in gzdoom.pk3, there are 3 "walk" uses and 1 "pressed use" uses.
			if (e.ActivationType == SPAC_Cross || e.ActivationType == SPAC_Use)
			{
				// already have the Communicator, so assume this line will fire its script
				let comm = pmo.FindInventory("Communicator", true);
				if (e.ActivatedLine.special == SendToCommunicator && comm)
				{
					Line ln = e.ActivatedLine;
					int voc_id = ln.args[0];
					int front_only = ln.args[1];
					int identify = ln.args[2];
					int nolog = ln.args[3];

					// handle each of the Strife-specific line types
					bool is201 = e.ActivationType == SPAC_Cross	&& (voc_id != 0 && front_only == 1 && identify == 0);
					bool is202 = e.ActivationType == SPAC_Cross	&& (voc_id != 0 && front_only == 0 && identify == 0);
					bool is210 = e.ActivationType == SPAC_Cross	&& (voc_id != 0 && front_only == 0 && identify == 0);
					bool is211 = e.ActivationType == SPAC_Use	&& (voc_id != 0 && front_only == 1 && identify == 2 && nolog == 1);

					// remove the original SendToCommunicator call
					ln.special = 0;

					// handle the mysterious line type 211... does it even exist?
					if (is211)
					{
						// Print it 10 times so that I won't miss it. :P
						for (int i = 0; i < 10; i++) { Console.Printf("MYSTERY LINE TYPE 211 FOUND!!!!!\nLine number %d in %s", ln.Index(), level.MapName); }

						// Turn it into an ACS line
						ln.special = ACS_ExecuteAlways;
						ln.args[0] = -int('StrifeCoop_SendToCommunicatorNoLog');
						ln.args[1] = 0;
						ln.args[2] = voc_id;
						ln.args[3] = front_only;
						ln.args[4] = identify;

						// return early
						return;
					}

					// broadcast to all players
					StrifeCoopHandler.BroadcastToCommunicators(pmo, voc_id, front_only, identify, nolog);
				}
			}
		}
	}

	static void BroadcastToCommunicators(Actor activator, int voc_id, int front_only, int identify, int nolog)
	{
		// From ACS you were sent...
		for (int i = 0; i < MAXPLAYERS; i++)
		{
			if (playeringame[i])
			{
				PlayerPawn currentPlayer = players[i].mo;
				if (currentPlayer == players[consoleplayer].mo)
				{
					// ... and to ACS you shall return :P
					if (nolog == 0)
					{
						currentPlayer.ACS_NamedExecuteAlways('StrifeCoop_SendToCommunicator', 0, voc_id, front_only, identify);
					}
					else if (nolog == 1)
					{
						currentPlayer.ACS_NamedExecuteAlways('StrifeCoop_SendToCommunicatorNoLog', 0, voc_id, front_only, identify);
					}
				}
			}
		}
	}

	static void PlayEntityGreeting(Actor activator, String soundToPlay)
	{
		// play The Entity's greeting sound and show subtitles for all players simultaneously
		for (int i = 0; i < MAXPLAYERS; i++)
		{
			if (playeringame[i])
			{
				let pmo = players[i].mo;
				if (pmo == players[consoleplayer].mo)
				{
					Sound snd = soundToPlay;
					if (snd) pmo.A_StartSound(snd, CHAN_AUTO, CHANF_UI, attenuation: ATTN_NONE);

					// remove these when PR gets merged
					if (soundToPlay == "svox/voc130") pmo.player.SetSubTitleNumber(128, "svox/voc130");
					else if (soundToPlay == "svox/voc128") pmo.player.SetSubTitleNumber(128, "svox/voc128");

					// use this when PR gets merged
					//pmo.A_GiveInventory("EntityGreetingSubtitles");
				}
			}
		}
	}

	//===========================================================================
	//
	//
	//
	//===========================================================================

	static bool PartyGathered(void)
	{
		if (!strifecoop_gatherparty) return true;

		bool gathered = true;

		Array<PlayerPawn> allPlayers;
		allPlayers.Clear();

		// store all online players in the array
		for (int i = 0; i < MAXPLAYERS; i++)
		{
			if (playeringame[i])
			{
				let pmo = players[i].mo;
				if (pmo)
				{
					allPlayers.Push(pmo);
					//Console.Printf("%s added into allPlayers", pmo.player.GetUserName());
				}
			}
		}

		// check distance between each player
		// if even one player fails the distance check, consider party not gathered
		for (int i = 0; i < allPlayers.Size(); i++)
		{
			let currentPlayer = allPlayers[i];

			// check the next player, but the last player must check against the first player
			let otherPlayer = i < (allPlayers.Size() - 1) ? allPlayers[i + 1] : allPlayers[0];

			if (currentPlayer && otherPlayer)
			{
				//Console.Printf("%s is checking against %s...", currentPlayer.player.GetUserName(), otherPlayer.player.GetUserName());

				// too far! abort the search
				if (currentPlayer.Distance3D(otherPlayer) > PARTY_DISTANCE)
				{
					//Console.Printf("%s is too far from %s", currentPlayer.player.GetUserName(), otherPlayer.player.GetUserName());
					gathered = false;
					break;
				}
				else
				{
					//Console.Printf("%s is close to %s", currentPlayer.player.GetUserName(), otherPlayer.player.GetUserName());
					continue;
				}
			}
		}

		return gathered;
	}

	//===========================================================================
	//
	//
	//
	//===========================================================================

	static clearscope void DrawDebugText(PlayerInfo plr, int debugMode)
	{
		int vw = 512,
			vh = 384;

		String debugText = GetDebugText(plr, debugMode);
		Screen.DrawText(NewConsoleFont, Font.CR_WHITE,
			0, 0,
			debugText,
			DTA_Clean, true, DTA_VirtualWidth, vw, DTA_VirtualHeight, vh);
	}

	static clearscope String GetDebugText(PlayerInfo plr, int debugTextMode)
	{
		String s;

		if (debugTextMode == 1)
		{
			if (plr && plr.mo)
			{
				PlayerPawn pmo = plr.mo;

				//===========================================================================
				//
				// Basic player info
				//
				//===========================================================================

				s = s .. String.Format("%s (Player %d)", plr.GetUserName(), pmo.PlayerNumber() + 1);
				s = s .. "\n";

				//===========================================================================
				//
				// ConversationNPC info
				//
				//===========================================================================

				String ConversationNPCName = "<none>";
				String ConversationNPCPtrAdr = "";
				bool hasConversationNPC = false;
				if (plr.ConversationNPC)
				{
					ConversationNPCName = plr.ConversationNPC.GetTag();
					ConversationNPCPtrAdr = String.Format("%p", plr.ConversationNPC);
					hasConversationNPC = true;
				}
				s = s .. String.Format
				(
					"%s %s %s",
					"ConversationNPC: ", ConversationNPCName, hasConversationNPC ? "[" .. ConversationNPCPtrAdr .. "]" : ""
				);
				s = s .. "\n";

				//===========================================================================
				//
				// ConversationPC info
				//
				//===========================================================================

				String ConversationPCName = "<none>";
				String ConversationPCPtrAdr = "";
				bool hasConversationPC = false;
				if (plr.ConversationPC)
				{
					ConversationPCName = plr.ConversationPC.GetTag();
					ConversationPCPtrAdr = String.Format("%p", plr.ConversationPC);
					hasConversationPC = true;
				}
				s = s .. String.Format
				(
					"%s %s %s",
					"ConversationPC: ", ConversationPCName, hasConversationPC ? "[" .. ConversationPCPtrAdr .. "]" : ""
				);
				s = s .. "\n";

				//===========================================================================
				//
				// Global player stat info
				//
				//===========================================================================

				let eh = StrifeCoopHandler(StrifeCoopHandler.Find("StrifeCoopHandler"));
				if (eh)
				{
					s = s .. String.Format
					(
						"Global stats -- maxStamina: %d, maxAccuracy: %d",
						eh.maxStamina, eh.maxAccuracy
					);
				}

				s = s .. "\n";

				s = s .. String.Format
				(
					"Your stats -- Stamina: %d, Accuracy: %d",
					pmo.Stamina, pmo.Accuracy
				);

				s = s .. "\n";
			}
		}
		else if (debugTextMode == 2)
		{
			//===========================================================================
			//
			// Retrieved Quest Items info
			//
			//===========================================================================

			s = "Retrieved Quest Items:" .. "\n\n";

			let eh = StrifeCoopHandler(StrifeCoopHandler.Find("StrifeCoopHandler"));

			if (eh)
			{
				if (eh.retrievedQuestItems.Size() > 0)
				{
					for (int i = 0; i < eh.retrievedQuestItems.Size(); i++)
					{
						s = s .. eh.retrievedQuestItems[i].GetClassName() .. "\n";
					}
				}
			}
		}
		else if (debugTextMode == 3)
		{
			//===========================================================================
			//
			// Quest Log info
			//
			//===========================================================================

			s = "Quest Log" .. "\n\n";
		}

		return s;
	}
}
