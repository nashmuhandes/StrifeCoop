// Copyright 2021 Nash Muhandes
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//===========================================================================
//
// StrifeCoopHandler
//
//===========================================================================

class StrifeCoopHandler : EventHandler
{
	const PARTY_DISTANCE = 200.0;

	// a reference to the campaign object MUST always exist!
	StrifeCoopCampaign campaign;

	transient CVar cvDebug;
	transient CVar cvChatBubble;

	//===========================================================================
	//
	//
	//
	//===========================================================================

	override void NewGame(void)
	{
		CreateCampaign();
	}

	override void PlayerEntered(PlayerEvent e)
	{
		let pmo = players[e.PlayerNumber].mo;
		if (pmo)
		{
			SetupPlayer(pmo);
		}
	}

	override void PlayerRespawned(PlayerEvent e)
	{
		let pmo = players[e.PlayerNumber].mo;
		if (pmo)
		{
			ResurrectPlayer(pmo);
		}
	}

	override void PlayerDied(PlayerEvent e)
	{
	}

	override void PlayerDisconnected(PlayerEvent e)
	{
		TransferQuestItems(e);
	}

	//===========================================================================
	//
	//
	//
	//===========================================================================

	override void WorldLoaded(WorldEvent e)
	{
		CacheCVars();
		GetCampaign();
		WakeStartingEnemiesInTown();
	}

	override void WorldTick(void)
	{
		if (!campaign)
		{
			ThrowAbortException("StrifeCoopHandler::WorldTick could not find a valid campaign object!");
			return;
		}

		campaign.Tick();
	}

	override void WorldUnloaded(WorldEvent e)
	{
		StopNPCVoices();
		StopPlayerConversations();
		ClearFloatingMessages();
	}

	override void WorldThingSpawned(WorldEvent e)
	{
		SetupNPC(e);
		ScaleNPCStats(e);
		ScaleAmmoPickupAmount(e);
	}

	override void WorldThingDied(WorldEvent e)
	{
		HandleAlienSpectre5Death(e);
	}

	override void WorldLinePreActivated(WorldEvent e)
	{
		HandleCommunicatorLines(e);
	}

	//===========================================================================
	//
	//
	//
	//===========================================================================

	override void NetworkProcess(ConsoleEvent e)
	{
		PlayerPawn pmo = PlayerPawn(players[e.Player].mo);
		if (!pmo) return;
		if (pmo && !pmo.player) return;
		bool isConsolePlayer = (pmo == PlayerPawn(players[consoleplayer].mo));

		//===========================================================================
		//
		// EV_ClearConversationStuff
		//
		//===========================================================================
		if (e.Name == 'EV_ClearConversationStuff')
		{
			let plugin = StrifeCoopPlayerPlugin.Find(pmo);
			if (plugin)
			{
				plugin.ClearConversationStuff(pmo.player);
			}
		}
	}

	//===========================================================================
	//
	//
	//
	//===========================================================================

	override void RenderOverlay(RenderEvent e)
	{
		PlayerInfo plr;
		if (e.Camera is "PlayerPawn" && e.Camera == players[consoleplayer].camera && e.Camera.player)
		{
			plr = e.Camera.player;
		}
		if (!plr) return;

		let eh = StrifeCoopHandler(StrifeCoopHandler.Find("StrifeCoopHandler"));
		if (!eh) return;
		int debugMode = eh.GetCachedCVar(plr, "strifecoop_debug", eh.cvDebug).GetInt();

		StrifeCoopDebugText.DrawDebugText(plr, debugMode);
	}

	//===========================================================================
	//
	//
	//
	//===========================================================================

	void CacheCVars(void)
	{
		cvDebug = CVar.GetCVar("strifecoop_debug", players[consoleplayer]);
		cvChatBubble = CVar.GetCVar("strifecoop_chatbubble", players[consoleplayer]);
	}

	clearscope CVar GetCachedCVar(PlayerInfo p, Name cvn, CVar cv)
	{
		if (!cv)
		{
			ThrowAbortException("CVar %s was not cached", cvn);
		}
		return cv;
	}

	//===========================================================================
	//
	//
	//
	//===========================================================================

	void CreateCampaign(void)
	{
		if (!campaign)
		{
			ThinkerIterator it = ThinkerIterator.Create("StrifeCoopCampaign", Thinker.STAT_STATIC);
			let p = StrifeCoopCampaign(it.Next());
			if (!p)
			{
				//Console.Printf("Creating a new campaign object...");
				campaign = new("StrifeCoopCampaign").Init();
			}
		}
	}

	void GetCampaign(void)
	{
		if (!campaign)
		{
			campaign = StrifeCoopCampaign.GetInstance();
		}

		if (!campaign)
		{
			ThrowAbortException("StrifeCoopHandler::GetCampaign could not find a campaign object");
		}
	}

	//===========================================================================
	//
	//
	//
	//===========================================================================

	void SetupPlayer(PlayerPawn pmo)
	{
		if (!pmo) return;

		//Console.Printf("SetupPlayer() running for player %d", pmo.PlayerNumber() + 1);

		// Enable player plugin
		let plugin = StrifeCoopPlayerPlugin.Find(pmo);
		if (!plugin)
		{
			pmo.A_GiveInventory("StrifeCoopPlayerPlugin");
		}

		if (plugin)
		{
			if (plugin.exitedLevel)
			{
				plugin.exitedLevel = false;
			}
		}
	}

	void ResurrectPlayer(PlayerPawn pmo)
	{
		if (!pmo) return;

		//Console.Printf("ResurrectPlayer() running for player %d", pmo.PlayerNumber() + 1);

		SetupPlayer(pmo);

		let plugin = StrifeCoopPlayerPlugin.Find(pmo);
		if (plugin)
		{
			//Console.Printf("Restoring stats for resurrected player %d", pmo.PlayerNumber() + 1);
			pmo.Stamina = campaign.maxStamina; pmo.GiveBody(-100);
			pmo.Accuracy = campaign.maxAccuracy;
			plugin.oldStamina = plugin.newStamina = campaign.maxStamina;
			plugin.oldAccuracy = plugin.newAccuracy = campaign.maxAccuracy;
		}
	}

	void HandlePlayersOnLoadedGame(void)
	{
		// TO DO: this can probably be done in a more robust way...
		for (int i = 0; i < MAXPLAYERS; i++)
		{
			if (playeringame[i])
			{
				let pmo = players[i].mo;
				if (pmo)
				{
					//Console.Printf("Handling a loaded save game for player %d", pmo.PlayerNumber() + 1);

					// the player doesn't have a plugin, so we can assume it's a newly-added player
					let plugin = StrifeCoopPlayerPlugin.Find(pmo);
					if (!plugin)
					{
						SetupPlayer(pmo);
						plugin = StrifeCoopPlayerPlugin.Find(pmo);
						plugin.isNewJoiningPlayer = true;
					}

				}
			}
		}
	}

	static clearscope int GetPlayerCount(void)
	{
		int p = 0;
		for (int i = 0; i < MAXPLAYERS; i++)
		{
			if (playeringame[i])
			{
				p++;
			}
		}
		return p;
	}

	//===========================================================================
	//
	//
	//
	//===========================================================================

	void SetupNPC(WorldEvent e)
	{
		// Inject custom logic into all NPCs
		if (e.Thing && e.Thing.bIsMonster)
		{
			Actor npc = e.Thing;
			npc.A_GiveInventory("StrifeCoopNPCPlugin", 1);
		}
	}

	void ScaleNPCStats(WorldEvent e)
	{
		if (!strifecoop_scaleenemies) return;

		if (e.Thing && StrifeCoopHandler.IsEnemy(e.Thing))
		{
			Actor npc = e.Thing;
			let plugin = StrifeCoopNPCPlugin.Find(npc);
			if (plugin)
			{
				plugin.ScaleStats();
			}
		}
	}

	//===========================================================================
	//
	//
	//
	//===========================================================================

	void ScaleAmmoPickupAmount(WorldEvent e)
	{
		if (!strifecoop_extraammo) return;

		if (e.Thing && e.Thing is "Ammo")
		{
			let ammo = Ammo(e.Thing);
			if (ammo)
			{
				//Console.Printf("%s ammo before: %d", ammo.GetTag(), ammo.Amount);
				double oa = int(ammo.Amount);
				oa *= (1.20 * StrifeCoopHandler.GetPlayerCount() - 1);
				ammo.Amount = int(oa);
				//Console.Printf("%s ammo after: %d", ammo.GetTag(), ammo.Amount);
			}
		}
	}

	//===========================================================================
	//
	//
	//
	//===========================================================================

	void WakeStartingEnemiesInTown(void)
	{
		if (!multiplayer) return;

		// Wake the Acolytes up in the first room immediately, targetting a random player
		if (level.totaltime == 0 && level.levelnum == 2)
		{
			int totalPlayers = 0;
			for (int i = 0; i < MAXPLAYERS; i++)
			{
				if (playeringame[i]) totalPlayers++;
			}

			int p = random[RNG_TargetRandomPlayer](0, totalPlayers - 1);

			players[p].mo.SoundAlert(players[p].mo, false);
		}
	}

	//===========================================================================
	//
	//
	//
	//===========================================================================

	void TransferQuestItems(PlayerEvent e)
	{
		// TO DO: when a player disconnects, transfer the pickup-able quest item
		// (Beldin's ring, power coupling etc) to the next online player.
	}

	//===========================================================================
	//
	//
	//
	//===========================================================================

	void HandleAlienSpectre5Death(WorldEvent e)
	{
		if (!multiplayer) return;

		// AlienSpectre5 (the Loremaster's spectre) is hardcoded to only give upgrades when killed in single player.
		// We deal with that here.
		// It's okay to give the upgrades to every player unconditionally because according the base class code,
		// players get ZERO upgrades in multiplayer :S
		if (e.Thing && e.Thing is "AlienSpectre5")
		{
			PlayerPawn pmo = NULL;
			for (int i = 0; i < MAXPLAYERS; ++i)
			{
				if (playeringame[i])
				{
					pmo = players[i].mo;
					if (pmo)
					{
						pmo.GiveInventoryType("UpgradeStamina");
						pmo.GiveInventoryType("UpgradeAccuracy");
					}
				}
			}
		}
	}

	//===========================================================================
	//
	//
	//
	//===========================================================================

	void HandleCommunicatorLines(WorldEvent e)
	{
		// This is for handling all of the lines that were directly given the "Sound Activate Comm Unit" lines,
		// instead of the ACS-based one
		if (e.Thing is "PlayerPawn")
		{
			PlayerPawn pmo = PlayerPawn(e.Thing);
			if (!pmo) return;

			// According to Strife's XLAT in gzdoom.pk3, there are 3 "walk" uses and 1 "pressed use" uses.
			if (e.ActivationType == SPAC_Cross || e.ActivationType == SPAC_Use)
			{
				// already have the Communicator, so assume this line will fire its script
				let comm = pmo.FindInventory("Communicator", true);
				if (e.ActivatedLine.special == SendToCommunicator && comm)
				{
					Line ln = e.ActivatedLine;
					int voc_id = ln.args[0];
					int front_only = ln.args[1];
					int identify = ln.args[2];
					int nolog = ln.args[3];

					// handle each of the Strife-specific line types
					bool is201 = e.ActivationType == SPAC_Cross	&& (voc_id != 0 && front_only == 1 && identify == 0);
					bool is202 = e.ActivationType == SPAC_Cross	&& (voc_id != 0 && front_only == 0 && identify == 0);
					bool is210 = e.ActivationType == SPAC_Cross	&& (voc_id != 0 && front_only == 0 && identify == 0);
					bool is211 = e.ActivationType == SPAC_Use	&& (voc_id != 0 && front_only == 1 && identify == 2 && nolog == 1);

					// remove the original SendToCommunicator call
					ln.special = 0;

					// handle the mysterious line type 211... does it even exist?
					if (is211)
					{
						// Print it 10 times so that I won't miss it. :P
						for (int i = 0; i < 10; i++) { Console.Printf("MYSTERY LINE TYPE 211 FOUND!!!!!\nLine number %d in %s", ln.Index(), level.MapName); }

						// Turn it into an ACS line
						ln.special = ACS_ExecuteAlways;
						ln.args[0] = -int('StrifeCoop_SendToCommunicatorNoLog');
						ln.args[1] = 0;
						ln.args[2] = voc_id;
						ln.args[3] = front_only;
						ln.args[4] = identify;

						// return early
						return;
					}

					// broadcast to all players
					StrifeCoopHandler.BroadcastToCommunicators(pmo, voc_id, front_only, identify, nolog);
				}
			}
		}
	}

	static void BroadcastToCommunicators(Actor activator, int voc_id, int front_only, int identify, int nolog)
	{
		// From ACS you were sent...
		for (int i = 0; i < MAXPLAYERS; i++)
		{
			if (playeringame[i])
			{
				PlayerPawn currentPlayer = players[i].mo;
				if (currentPlayer == players[consoleplayer].mo)
				{
					// ... and to ACS you shall return :P
					if (nolog == 0)
					{
						currentPlayer.ACS_NamedExecuteAlways('StrifeCoop_SendToCommunicator', 0, voc_id, front_only, identify);
					}
					else if (nolog == 1)
					{
						currentPlayer.ACS_NamedExecuteAlways('StrifeCoop_SendToCommunicatorNoLog', 0, voc_id, front_only, identify);
					}
				}
			}
		}
	}

	static void PlayEntityGreeting(Actor activator, String soundToPlay)
	{
		// play The Entity's greeting sound and show subtitles for all players simultaneously
		for (int i = 0; i < MAXPLAYERS; i++)
		{
			if (playeringame[i])
			{
				let pmo = players[i].mo;
				if (pmo == players[consoleplayer].mo)
				{
					Sound snd = soundToPlay;
					if (snd) pmo.A_StartSound(snd, CHAN_AUTO, CHANF_UI, attenuation: ATTN_NONE);

					// remove these when PR gets merged
					if (soundToPlay == "svox/voc130") pmo.player.SetSubTitleNumber(130, "svox/voc130");
					else if (soundToPlay == "svox/voc128") pmo.player.SetSubTitleNumber(128, "svox/voc128");

					// use this when PR gets merged
					//pmo.A_GiveInventory("EntityGreetingSubtitles");
				}
			}
		}
	}

	//===========================================================================
	//
	//
	//
	//===========================================================================

	static clearscope bool IsTalkableNPC(Actor mo)
	{
		return
		(
			mo is "StrifeHumanoid"	||
			mo is "Macil1"			||
			mo is "Oracle"			||
			mo is "SpectralMonster"	||
			mo is "Merchant"
		);
	}

	static clearscope bool IsEnemy(Actor mo)
	{
		if (!mo.bIsMonster || (mo.bIsMonster && mo.bFriendly)) return false;

		return
		(
			mo is "Acolyte"			||
			mo is "SpectralMonster"	||
			mo is "Crusader"		||
			mo is "Inquisitor"		||
			mo is "LoreMaster"		||
			mo is "Macil1"			||
			mo is "Programmer"		||
			mo is "Reaver"			||
			mo is "Sentinel"		||
			mo is "Stalker"			||
			mo is "Templar"
		);
	}

	static clearscope bool IsMerchant(Actor mo)
	{
		return (mo is "Merchant");
	}

	//===========================================================================
	//
	//
	//
	//===========================================================================

	void StopNPCVoices(void)
	{
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor mo;
		while (mo = Actor(it.Next()))
		{
			if (StrifeCoopHandler.IsTalkableNPC(mo) && mo.IsActorPlayingSound(CHAN_VOICE))
			{
				mo.A_StopSound(CHAN_VOICE);
			}

			if (mo.bInConversation)
			{
				mo.bInConversation = false;
			}
		}
	}

	void StopPlayerConversations(void)
	{
		for (int i = 0; i < MAXPLAYERS; i++)
		{
			if (playeringame[i])
			{
				let pmo = players[i].mo;
				if (pmo)
				{
					let plugin = StrifeCoopPlayerPlugin.Find(pmo);
					if (plugin)
					{
						if (gameaction != ga_slideshow)
						{
							plugin.ClearConversationStuff(pmo.player);
							plugin.exitedLevel = true;
						}
					}
				}
			}
		}
	}

	void ClearFloatingMessages(void)
	{
		Console.MidPrint(NULL, "");
	}

	//===========================================================================
	//
	//
	//
	//===========================================================================

	static bool PartyGathered(void)
	{
		if (!strifecoop_gatherparty) return true;

		bool gathered = true;

		Array<PlayerPawn> allPlayers;
		allPlayers.Clear();

		// store all online players in the array
		for (int i = 0; i < MAXPLAYERS; i++)
		{
			if (playeringame[i])
			{
				let pmo = players[i].mo;
				if (pmo)
				{
					allPlayers.Push(pmo);
					//Console.Printf("%s added into allPlayers", pmo.player.GetUserName());
				}
			}
		}

		// check distance between each player
		// if even one player fails the distance check, consider party not gathered
		for (int i = 0; i < allPlayers.Size(); i++)
		{
			let currentPlayer = allPlayers[i];

			// check the next player, but the last player must check against the first player
			let otherPlayer = i < (allPlayers.Size() - 1) ? allPlayers[i + 1] : allPlayers[0];

			if (currentPlayer && otherPlayer)
			{
				//Console.Printf("%s is checking against %s...", currentPlayer.player.GetUserName(), otherPlayer.player.GetUserName());

				// too far! abort the search
				if (currentPlayer.Distance3D(otherPlayer) > PARTY_DISTANCE)
				{
					//Console.Printf("%s is too far from %s", currentPlayer.player.GetUserName(), otherPlayer.player.GetUserName());
					gathered = false;
					break;
				}
				else
				{
					//Console.Printf("%s is close to %s", currentPlayer.player.GetUserName(), otherPlayer.player.GetUserName());
					continue;
				}
			}
		}

		return gathered;
	}
}
