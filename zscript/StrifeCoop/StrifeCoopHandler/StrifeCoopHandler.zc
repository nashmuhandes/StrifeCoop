// Copyright 2021 Nash Muhandes
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//===========================================================================
//
// StrifeCoopHandler
//
//===========================================================================

class StrifeCoopHandler : EventHandler
{
	const PARTY_DISTANCE = 200.0;

	// a reference to the campaign object MUST always exist!
	StrifeCoopCampaign campaign;

	// keep a global record of QuestItems acquired throughout the journey
	Array< class<Inventory> > retrievedQuestItems;

	//===========================================================================
	//
	//
	//
	//===========================================================================

	override void NewGame(void)
	{
		CreateCampaign();
	}

	override void PlayerEntered(PlayerEvent e)
	{
		let pmo = players[e.PlayerNumber].mo;
		if (pmo)
		{
			SetupPlayer(pmo);
		}
	}

	override void PlayerRespawned(PlayerEvent e)
	{
		let pmo = players[e.PlayerNumber].mo;
		if (pmo)
		{
			ResurrectPlayer(pmo);
		}
	}

	override void PlayerDied(PlayerEvent e)
	{
	}

	override void PlayerDisconnected(PlayerEvent e)
	{
		TransferQuestItems(e);
	}

	//===========================================================================
	//
	//
	//
	//===========================================================================

	override void WorldLoaded(WorldEvent e)
	{
		GetCampaign();
		WakeStartingEnemiesInTown();
	}

	override void WorldTick(void)
	{
		if (!campaign)
		{
			ThrowAbortException("StrifeCoopHandler::WorldTick could not find a valid campaign object!");
			return;
		}

		// have to manually tick the campaign because STAT_STATIC thinkers don't automatically tick...
		campaign.Tick();

		HandleQuestItems();
	}

	override void WorldUnloaded(WorldEvent e)
	{
	}

	override void WorldThingSpawned(WorldEvent e)
	{
		SetupNPCs(e);
	}

	override void WorldThingDied(WorldEvent e)
	{
		HandleAlienSpectre5Death(e);
	}

	override void WorldLinePreActivated(WorldEvent e)
	{
		HandleCommunicatorLines(e);
	}

	//===========================================================================
	//
	//
	//
	//===========================================================================

	override void NetworkProcess(ConsoleEvent e)
	{
		PlayerPawn pmo = PlayerPawn(players[e.Player].mo);
		if (!pmo) return;
		if (pmo && !pmo.player) return;
		bool isConsolePlayer = (pmo == PlayerPawn(players[consoleplayer].mo));

		//===========================================================================
		//
		// EV_ClearConversationStuff
		//
		//===========================================================================
		if (e.Name == 'EV_ClearConversationStuff')
		{
			pmo.player.ConversationFaceTalker = false;
			pmo.player.ConversationNPC = NULL;
			pmo.player.ConversationPC = NULL;
			pmo.player.ConversationNPCAngle = 0.;
		}
	}

	//===========================================================================
	//
	//
	//
	//===========================================================================

	override void RenderOverlay(RenderEvent e)
	{
		PlayerInfo plr;

		if (e.Camera is "PlayerPawn" && e.Camera == players[consoleplayer].camera && e.Camera.player)
		{
			plr = e.Camera.player;
		}

		if (!plr) return;

		int debugMode = CVar.GetCVar("strifecoop_debug", plr).GetInt();
		if (debugMode <= 0) return;

		StrifeCoopDebugText.DrawDebugText(plr, debugMode);
	}

	//===========================================================================
	//
	//
	//
	//===========================================================================

	void CreateCampaign(void)
	{
		if (!campaign)
		{
			ThinkerIterator it = ThinkerIterator.Create("StrifeCoopCampaign", Thinker.STAT_STATIC);
			let p = StrifeCoopCampaign(it.Next());
			if (!p)
			{
				Console.Printf("Creating a new campaign object...");
				campaign = new("StrifeCoopCampaign").Init();
			}
		}
	}

	void GetCampaign(void)
	{
		if (!campaign)
		{
			campaign = StrifeCoopCampaign.GetInstance();
		}

		if (!campaign)
		{
			ThrowAbortException("StrifeCoopHandler::GetCampaign could not find a campaign object");
		}
	}

	//===========================================================================
	//
	//
	//
	//===========================================================================

	void SetupPlayer(PlayerPawn pmo)
	{
		if (!pmo) return;

		Console.Printf("SetupPlayer() running for player %d", pmo.PlayerNumber() + 1);

		// Enable player plugin
		let plugin = StrifeCoopPlayerPlugin(pmo.FindInventory("StrifeCoopPlayerPlugin", true));
		if (!plugin)
		{
			pmo.A_GiveInventory("StrifeCoopPlayerPlugin");
		}
	}

	void ResurrectPlayer(PlayerPawn pmo)
	{
		if (!pmo) return;

		Console.Printf("ResurrectPlayer() running for player %d", pmo.PlayerNumber() + 1);

		SetupPlayer(pmo);

		let plugin = StrifeCoopPlayerPlugin(pmo.FindInventory("StrifeCoopPlayerPlugin", true));
		if (plugin)
		{
			Console.Printf("Restoring stats for player %d", pmo.PlayerNumber() + 1);
			pmo.Stamina = campaign.maxStamina; pmo.GiveBody(-100);
			pmo.Accuracy = campaign.maxAccuracy;
			plugin.oldStamina = plugin.newStamina = campaign.maxStamina;
			plugin.oldAccuracy = plugin.newAccuracy = campaign.maxAccuracy;
		}
	}

	void SetupNPCs(WorldEvent e)
	{
		// Inject custom logic into all NPCs
		if (e.Thing && e.Thing.bIsMonster)
		{
			Actor npc = e.Thing;
			npc.A_GiveInventory("StrifeCoopNPCPlugin", 1);
		}
	}

	void HandlePlayersOnLoadedGame(void)
	{
		// TO DO: this can probably be done in a more robust way...
		for (int i = 0; i < MAXPLAYERS; i++)
		{
			if (playeringame[i])
			{
				let pmo = players[i].mo;
				SetupPlayer(pmo);
				Console.Printf("Handling a loaded save game for player %d", pmo.PlayerNumber() + 1);
			}
		}
	}

	//===========================================================================
	//
	//
	//
	//===========================================================================

	void WakeStartingEnemiesInTown(void)
	{
		if (!multiplayer) return;

		// Wake the Acolytes up in the first room immediately, targetting a random player
		if (level.totaltime == 0 && level.levelnum == 2)
		{
			int totalPlayers = 0;
			for (int i = 0; i < MAXPLAYERS; i++)
			{
				if (playeringame[i]) totalPlayers++;
			}

			int p = random[RNG_TargetRandomPlayer](0, totalPlayers - 1);

			players[p].mo.SoundAlert(players[p].mo, false);
		}
	}

	//===========================================================================
	//
	//
	//
	//===========================================================================

	void HandleQuestItems(void)
	{
		if (!multiplayer) return;

		// No, there really isn't a better way to do this for the vanilla quest items.
		// Actor replacement doesn't work because too many parts of the game check for the
		// original items directly by class name.

		// First, collect all of the items each player has
		for (int i = 0; i < MAXPLAYERS; i++)
		{
			if (playeringame[i])
			{
				PlayerInfo plr = players[i];
				let pmo = players[i].mo;

				if (pmo && plr)
				{
					for (Inventory item = pmo.Inv; item != NULL; item = item.Inv)
					{
						if (item is "QuestItem" || item is "Communicator" || item is "StrifeKey" || item is "PrisonPass")
						{
							class<Inventory> cls = item.GetClass();
							if (cls)
							{
								if (retrievedQuestItems.Find(cls) == retrievedQuestItems.Size())
								{
									//Console.Printf("Found %s on player %d", cls.GetClassName(), pmo.PlayerNumber() + 1);
									retrievedQuestItems.Push(cls);
								}
							}
						}
					}
				}
			}
		}

		// Then, distribute the items to all players
		for (int i = 0; i < MAXPLAYERS; i++)
		{
			if (playeringame[i])
			{
				PlayerInfo plr = players[i];
				let pmo = players[i].mo;

				if (pmo && plr)
				{
					for (int j = 0; j < retrievedQuestItems.Size(); j++)
					{
						let a = pmo.FindInventory(retrievedQuestItems[j], true);
						if (!a)
						{
							//Console.Printf("Giving %s to player %d", retrievedQuestItems[j].GetClassName(), pmo.PlayerNumber() + 1);
							pmo.A_GiveInventory(retrievedQuestItems[j], 1);
						}
					}
				}
			}
		}
	}

	void TransferQuestItems(PlayerEvent e)
	{
		// TO DO: when a player disconnects, transfer the pickup-able quest item
		// (Beldin's ring, power coupling etc) to the next online player.
	}

	//===========================================================================
	//
	//
	//
	//===========================================================================

	void HandleAlienSpectre5Death(WorldEvent e)
	{
		if (!multiplayer) return;

		// AlienSpectre5 (the Loremaster's spectre) is hardcoded to only give upgrades when killed in single player.
		// We deal with that here.
		// It's okay to give the upgrades to every player unconditionally because according the base class code,
		// players get ZERO upgrades in multiplayer :S
		if (e.Thing && e.Thing is "AlienSpectre5")
		{
			PlayerPawn pmo = NULL;
			for (int i = 0; i < MAXPLAYERS; ++i)
			{
				if (playeringame[i])
				{
					pmo = players[i].mo;
					if (pmo)
					{
						pmo.GiveInventoryType("UpgradeStamina");
						pmo.GiveInventoryType("UpgradeAccuracy");
					}
				}
			}
		}
	}

	//===========================================================================
	//
	//
	//
	//===========================================================================

	void HandleCommunicatorLines(WorldEvent e)
	{
		// This is for handling all of the lines that were directly given the "Sound Activate Comm Unit" lines,
		// instead of the ACS-based one
		if (e.Thing is "PlayerPawn")
		{
			PlayerPawn pmo = PlayerPawn(e.Thing);
			if (!pmo) return;

			// According to Strife's XLAT in gzdoom.pk3, there are 3 "walk" uses and 1 "pressed use" uses.
			if (e.ActivationType == SPAC_Cross || e.ActivationType == SPAC_Use)
			{
				// already have the Communicator, so assume this line will fire its script
				let comm = pmo.FindInventory("Communicator", true);
				if (e.ActivatedLine.special == SendToCommunicator && comm)
				{
					Line ln = e.ActivatedLine;
					int voc_id = ln.args[0];
					int front_only = ln.args[1];
					int identify = ln.args[2];
					int nolog = ln.args[3];

					// handle each of the Strife-specific line types
					bool is201 = e.ActivationType == SPAC_Cross	&& (voc_id != 0 && front_only == 1 && identify == 0);
					bool is202 = e.ActivationType == SPAC_Cross	&& (voc_id != 0 && front_only == 0 && identify == 0);
					bool is210 = e.ActivationType == SPAC_Cross	&& (voc_id != 0 && front_only == 0 && identify == 0);
					bool is211 = e.ActivationType == SPAC_Use	&& (voc_id != 0 && front_only == 1 && identify == 2 && nolog == 1);

					// remove the original SendToCommunicator call
					ln.special = 0;

					// handle the mysterious line type 211... does it even exist?
					if (is211)
					{
						// Print it 10 times so that I won't miss it. :P
						for (int i = 0; i < 10; i++) { Console.Printf("MYSTERY LINE TYPE 211 FOUND!!!!!\nLine number %d in %s", ln.Index(), level.MapName); }

						// Turn it into an ACS line
						ln.special = ACS_ExecuteAlways;
						ln.args[0] = -int('StrifeCoop_SendToCommunicatorNoLog');
						ln.args[1] = 0;
						ln.args[2] = voc_id;
						ln.args[3] = front_only;
						ln.args[4] = identify;

						// return early
						return;
					}

					// broadcast to all players
					StrifeCoopHandler.BroadcastToCommunicators(pmo, voc_id, front_only, identify, nolog);
				}
			}
		}
	}

	static void BroadcastToCommunicators(Actor activator, int voc_id, int front_only, int identify, int nolog)
	{
		// From ACS you were sent...
		for (int i = 0; i < MAXPLAYERS; i++)
		{
			if (playeringame[i])
			{
				PlayerPawn currentPlayer = players[i].mo;
				if (currentPlayer == players[consoleplayer].mo)
				{
					// ... and to ACS you shall return :P
					if (nolog == 0)
					{
						currentPlayer.ACS_NamedExecuteAlways('StrifeCoop_SendToCommunicator', 0, voc_id, front_only, identify);
					}
					else if (nolog == 1)
					{
						currentPlayer.ACS_NamedExecuteAlways('StrifeCoop_SendToCommunicatorNoLog', 0, voc_id, front_only, identify);
					}
				}
			}
		}
	}

	static void PlayEntityGreeting(Actor activator, String soundToPlay)
	{
		// play The Entity's greeting sound and show subtitles for all players simultaneously
		for (int i = 0; i < MAXPLAYERS; i++)
		{
			if (playeringame[i])
			{
				let pmo = players[i].mo;
				if (pmo == players[consoleplayer].mo)
				{
					Sound snd = soundToPlay;
					if (snd) pmo.A_StartSound(snd, CHAN_AUTO, CHANF_UI, attenuation: ATTN_NONE);

					// remove these when PR gets merged
					if (soundToPlay == "svox/voc130") pmo.player.SetSubTitleNumber(128, "svox/voc130");
					else if (soundToPlay == "svox/voc128") pmo.player.SetSubTitleNumber(128, "svox/voc128");

					// use this when PR gets merged
					//pmo.A_GiveInventory("EntityGreetingSubtitles");
				}
			}
		}
	}

	//===========================================================================
	//
	//
	//
	//===========================================================================

	static bool PartyGathered(void)
	{
		if (!strifecoop_gatherparty) return true;

		bool gathered = true;

		Array<PlayerPawn> allPlayers;
		allPlayers.Clear();

		// store all online players in the array
		for (int i = 0; i < MAXPLAYERS; i++)
		{
			if (playeringame[i])
			{
				let pmo = players[i].mo;
				if (pmo)
				{
					allPlayers.Push(pmo);
					//Console.Printf("%s added into allPlayers", pmo.player.GetUserName());
				}
			}
		}

		// check distance between each player
		// if even one player fails the distance check, consider party not gathered
		for (int i = 0; i < allPlayers.Size(); i++)
		{
			let currentPlayer = allPlayers[i];

			// check the next player, but the last player must check against the first player
			let otherPlayer = i < (allPlayers.Size() - 1) ? allPlayers[i + 1] : allPlayers[0];

			if (currentPlayer && otherPlayer)
			{
				//Console.Printf("%s is checking against %s...", currentPlayer.player.GetUserName(), otherPlayer.player.GetUserName());

				// too far! abort the search
				if (currentPlayer.Distance3D(otherPlayer) > PARTY_DISTANCE)
				{
					//Console.Printf("%s is too far from %s", currentPlayer.player.GetUserName(), otherPlayer.player.GetUserName());
					gathered = false;
					break;
				}
				else
				{
					//Console.Printf("%s is close to %s", currentPlayer.player.GetUserName(), otherPlayer.player.GetUserName());
					continue;
				}
			}
		}

		return gathered;
	}
}
